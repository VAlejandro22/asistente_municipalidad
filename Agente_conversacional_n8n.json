{
  "name": "Agente conversacional",
  "nodes": [
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1.2,
      "position": [
        3408,
        2864
      ],
      "id": "ae1471df-2147-43d2-9ff4-9e69ca5725e7",
      "name": "Embeddings OpenAI",
      "credentials": {
        "openAiApi": {
          "id": "FnGS5Jhx56bncQXg",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1,
      "position": [
        3984,
        2768
      ],
      "id": "b72c0f47-bfdb-45b6-a6f1-4eaa35ce8aa0",
      "name": "Default Data Loader"
    },
    {
      "parameters": {
        "fieldsToSummarize": {
          "values": [
            {
              "aggregation": "concatenate",
              "field": "text",
              "separateBy": "other",
              "customSeparator": "##SPLIT##"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.summarize",
      "typeVersion": 1.1,
      "position": [
        3248,
        2384
      ],
      "id": "826cd24e-48fb-4599-b84c-898e71a1da14",
      "name": "Summarize"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=<chunk>\n{{ $json.chunk }}\n</chunk>",
        "messages": {
          "messageValues": [
            {
              "message": "=# Prompt\n\n## Identidad del agente\nEres un especialista en optimizaci√≥n de sistemas RAG (Recuperaci√≥n Aumentada por Generaci√≥n). Tu misi√≥n es enriquecer fragmentos de texto (chunks) con contexto relevante y corregir incompletitudes m√≠nimas para maximizar su efectividad en b√∫squedas sem√°nticas.\n\n## Contexto del documento\nEl siguiente documento es la fuente completa de todos los chunks que procesar√°s:\n\n```\n{{ $(\"PDF TO DATA\").item.json.data }}\n```\n\n## Instrucciones principales\n\nPara cada chunk que recibas, realizar√°s dos tareas espec√≠ficas:\n\n### Tarea 1: Generaci√≥n de contexto enriquecido\nRedacta un p√°rrafo contextual (50-150 palabras) que:\n- Identifique la secci√≥n/cap√≠tulo del documento\n- Describa el tema principal y subtemas relevantes\n- Incluya palabras clave sem√°nticamente importantes\n- Explique la funci√≥n/prop√≥sito del fragmento\n- Mencione relaciones con otras secciones si es relevante\n\n### Tarea 2: Preservaci√≥n y correcci√≥n selectiva\nDevuelve el chunk original, corrigi√©ndolo √öNICAMENTE si presenta:\n\n**Criterios de correcci√≥n obligatoria:**\n- Oraciones cortadas que no terminan naturalmente\n- Tablas Markdown con filas/columnas incompletas o sintaxis rota\n- Referencias truncadas (\"como se ve en la Figura...\" sin n√∫mero)\n- Datos num√©ricos parciales (porcentajes, fechas, cantidades)\n- Listas Markdown numeradas/con vi√±etas incompletas\n- Bloques de c√≥digo con sintaxis ``` incompleta\n- Enlaces Markdown malformados `[texto](` sin cerrar\n- Encabezados Markdown cortados\n\n**Preservar siempre:**\n- Estilo y tono original\n- Terminolog√≠a espec√≠fica\n- Estructura de p√°rrafos\n- Formato de tablas completas\n\n## Reglas de formato\n\n### Formato de salida obligatorio:\n```\n[P√°rrafo de contexto sin encabezados ni referencias directas al chunk]\n\n[Chunk original o corregido seg√∫n criterios anteriores]\n```\n\n### Restricciones:\n- No agregues comentarios, explicaciones o metadatos\n- No uses encabezados como \"Contexto:\" o \"Chunk:\"\n- No alteres el contenido m√°s all√° de las correcciones especificadas\n- Mant√©n la longitud del contexto entre 50-150 palabras\n\n## Casos especiales\n\n**Documentos largos:** Si el documento excede 10,000 palabras, enf√≥cate en el contexto inmediato (secci√≥n actual + secciones adyacentes).\n\n**Chunks t√©cnicos:** Para c√≥digo, f√≥rmulas o tablas complejas, el contexto debe explicar su prop√≥sito funcional sin reproducir el contenido t√©cnico.\n\n**Referencias cruzadas:** Si el chunk referencia otras partes del documento, incluye esa informaci√≥n en el contexto para mantener coherencia sem√°ntica.\n\n## Manejo espec√≠fico de elementos Markdown\n\n### Tablas en Markdown\n**IMPORTANTE:** Todos los documentos est√°n en formato Markdown. Para tablas, aplica estas reglas:\n\n**Contexto para tablas:**\n- Describe qu√© tipo de datos presenta la tabla\n- Menciona las columnas principales y su prop√≥sito\n- Explica c√≥mo se relaciona con el contenido circundante\n- Identifica patrones, tendencias o datos destacados\n- Especifica si es una tabla de referencia, comparativa, o resultados\n\n**Correcci√≥n de tablas incompletas:**\n```markdown\n# Si encuentras:\n| Columna1 | Columna2 |\n|----------|----------|\n| Dato1    | Dato2    |\n| Dato3    |          |  ‚Üê Fila incompleta\n\n# Completa usando el documento fuente:\n| Columna1 | Columna2 |\n|----------|----------|\n| Dato1    | Dato2    |\n| Dato3    | Dato4    |\n```\n\n**Preservar formato Markdown:**\n- Mant√©n la sintaxis exacta de separadores `|` y `---`\n- Conserva el alineamiento de columnas\n- No alteres encabezados de tabla existentes\n- Preserva cualquier formato interno (negrita, cursiva, enlaces)\n\n### Otros elementos Markdown\n\n**Listas:** \n- Preserva numeraci√≥n (`1.`, `2.`) o vi√±etas (`-`, `*`)\n- Completa listas cortadas manteniendo el formato original\n- Mant√©n niveles de anidaci√≥n con espacios/tabs\n\n**C√≥digo:**\n- Preserva bloques de c√≥digo con ``` o `\n- No modifiques el contenido del c√≥digo\n- El contexto debe explicar qu√© hace el c√≥digo, no reproducirlo\n\n**Enlaces y referencias:**\n- Formato: `[texto](url)` o `[texto][referencia]`\n- Si est√° incompleto, busca la referencia completa en el documento\n- Preserva la sintaxis exacta de Markdown\n\n**Encabezados:**\n- Mant√©n niveles (`#`, `##`, `###`, etc.)\n- Si un chunk inicia con encabezado cortado, compl√©talo desde el documento"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.6,
      "position": [
        2928,
        2384
      ],
      "id": "45b5a15c-c05c-4339-9a0c-06c5ea9d405b",
      "name": "Add Context"
    },
    {
      "parameters": {
        "separator": "##SPLIT##"
      },
      "type": "@n8n/n8n-nodes-langchain.textSplitterCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        4048,
        2960
      ],
      "id": "2f7091d5-4c30-49d5-82cf-b443e795b174",
      "name": "Character Text Splitter"
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        1888,
        2208
      ],
      "id": "ba0b8f9c-3709-42a2-8fe6-1336b6aaab8a",
      "name": "Extract from PDF"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n \"data\": {{JSON.stringify($json.data)}}\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2224,
        2240
      ],
      "id": "871312d7-a917-4440-a0ad-60c4af2e9515",
      "name": "PDF TO DATA"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $binary.data.fileExtension }}",
                    "rightValue": "pdf",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "64bba165-0d1c-4726-89c8-c2b6dca27d8f"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "PDF"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "c85fb22e-0117-4a8e-b877-2b0af70a0d11",
                    "leftValue": "={{ $binary.data.fileExtension }}",
                    "rightValue": "=txt",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "TXT"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a8fc55f3-900f-4a1f-b88a-0127bf19c937",
                    "leftValue": "={{ $binary.data.fileExtension }}",
                    "rightValue": "csv",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CSV"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "60006fa0-f791-4b17-8c37-6edcd3842b60",
                    "leftValue": "={{ $binary.data.fileExtension }}",
                    "rightValue": "md",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Markdown"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        1440,
        2400
      ],
      "id": "86268fc4-6464-4610-a4b8-4c8ce275a9cd",
      "name": "CR SWITCH"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"data\": {{ JSON.stringify($json.data) }}\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2384,
        2368
      ],
      "id": "6ec35d69-3bd5-496e-ae9c-2ef602f5d696",
      "name": "Document Data"
    },
    {
      "parameters": {
        "jsCode": "const maxChunkSize = 1000;\nconst chunkOverlap = 100;\n\nconst text = $json.data;\n\n// Funci√≥n para dividir el texto sin cortar palabras\nfunction splitTextByWords(text, maxChunkSize, chunkOverlap) {\n\tconst words = text.split(/\\s+/); // divide por espacios y saltos de l√≠nea\n\tconst chunks = [];\n\n\tlet chunk = '';\n\tfor (let i = 0; i < words.length; i++) {\n\t\tconst word = words[i];\n\t\tif ((chunk + ' ' + word).length <= maxChunkSize) {\n\t\t\tchunk += (chunk ? ' ' : '') + word;\n\t\t} else {\n\t\t\tchunks.push(chunk.trim());\n\n\t\t\t// Generar la superposici√≥n basada en palabras desde el final del chunk anterior\n\t\t\tconst chunkWords = chunk.split(/\\s+/);\n\t\t\tconst overlapWords = chunkWords.slice(-Math.floor(chunkOverlap / 5)); // estimamos 5 caracteres por palabra\n\t\t\tchunk = overlapWords.join(' ') + ' ' + word;\n\t\t}\n\t}\n\tif (chunk) chunks.push(chunk.trim());\n\n\treturn chunks;\n}\n\nconst resultChunks = splitTextByWords(text, maxChunkSize, chunkOverlap);\n\nreturn resultChunks.map((chunk, index) => ({\n\tjson: {\n\t\tchunkIndex: index + 1,\n\t\ttext: chunk\n\t}\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2560,
        2384
      ],
      "id": "d6ac9cfc-62d6-4015-9752-efd2923eff7d",
      "name": "Recursive Splitter"
    },
    {
      "parameters": {
        "fieldToSplitOut": "text",
        "options": {
          "destinationFieldName": "chunk"
        }
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        2720,
        2384
      ],
      "id": "d68a8ee8-ace6-476a-acd5-5f3fa011cfa3",
      "name": "Split Chunks"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        2880,
        2576
      ],
      "id": "4882b095-abee-4bd9-a1d9-2697b9c3e9af",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "FnGS5Jhx56bncQXg",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        1040,
        2416
      ],
      "id": "0f0a1cb5-bd1e-49d6-a3e5-5641af57367f",
      "name": "When clicking ‚ÄòTest workflow‚Äô"
    },
    {
      "parameters": {
        "mode": "insert",
        "tableName": {
          "__rl": true,
          "value": "documents",
          "mode": "list",
          "cachedResultName": "documents"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStoreSupabase",
      "typeVersion": 1.1,
      "position": [
        3504,
        2640
      ],
      "id": "34955ef5-5fbb-4fa6-93b0-bea603bb6bf7",
      "name": "Supabase Vector Store",
      "credentials": {
        "supabaseApi": {
          "id": "cdvkLWNHBA2y1xfO",
          "name": "Supabase account 2"
        }
      }
    },
    {
      "parameters": {
        "operation": "text",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        1888,
        2416
      ],
      "id": "ec06c1fd-0c44-47b0-84e4-75bc990c0f38",
      "name": "Extract from TXT"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        1840,
        2608
      ],
      "id": "db3b1ea1-f658-4a2c-b2a0-2b6c15a0a684",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "6163dc83-01b5-4657-9ae5-b61e9fdc79cb",
              "name": "text",
              "value": "={{ $json.data[1].text }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2336,
        2928
      ],
      "id": "a5781b43-575c-464a-a247-3eb1eaf62da5",
      "name": "Edit Fields2"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1504,
        3104
      ],
      "id": "2999bf14-37f6-459b-a0df-211513556784",
      "name": "OpenAI Chat Model2",
      "credentials": {
        "openAiApi": {
          "id": "FnGS5Jhx56bncQXg",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "e8926558-d223-465d-871e-e2e72a0988b7",
              "name": "text",
              "value": "={{ $json.text }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1840,
        2928
      ],
      "id": "406d7d8c-3db5-4a81-9e44-a9825e704278",
      "name": "Edit Fields4"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-opus-4-20250514",
          "mode": "list",
          "cachedResultName": "Claude Opus 4"
        },
        "options": {
          "thinking": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        2000,
        3104
      ],
      "id": "1e43931b-7f0b-4098-aca4-215fcaf782c1",
      "name": "Anthropic Chat Model",
      "disabled": true
    },
    {
      "parameters": {
        "fieldToSplitOut": "organized_text",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        2864,
        2928
      ],
      "id": "26753a2c-3189-4840-a45e-f6d846219b3c",
      "name": "Split Out"
    },
    {
      "parameters": {
        "fieldsToSummarize": {
          "values": [
            {
              "aggregation": "concatenate",
              "field": "organized_text",
              "separateBy": "other",
              "customSeparator": "##SPLIT##"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.summarize",
      "typeVersion": 1.1,
      "position": [
        3040,
        2928
      ],
      "id": "e219112b-8871-4459-8503-d26e67ec2777",
      "name": "Summarize1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=# PROMPT PARA AN√ÅLISIS ESTRAT√âGICO DE CSV PARA RAG\n\nEres un experto en sistemas RAG y optimizaci√≥n de datos para b√∫squeda sem√°ntica. Analiza el siguiente reporte de estructura CSV y genera un an√°lisis estrat√©gico que maximice la calidad de los chunks para vectorizaci√≥n.\n\n## RESTRICCIONES T√âCNICAS CR√çTICAS\n- **L√çMITE ABSOLUTO**: Cada chunk final debe ser ‚â§1500 caracteres de texto plano\n- **FORMATO OUTPUT**: Texto consolidado (no JSON) para vectorizaci√≥n directa\n- **IMPLEMENTACI√ìN**: El c√≥digo ser√° ejecutado en n8n con JavaScript\n\n## AN√ÅLISIS REQUERIDO\n\n### 1. **IDENTIFICACI√ìN DEL DOMINIO Y TIPO DE DATASET**\nClasifica el dataset en una de estas categor√≠as y ajusta tu estrategia:\n- **CAT√ÅLOGO**: Productos, servicios, inventarios ‚Üí chunks por categor√≠a/tipo\n- **TRANSACCIONAL**: Ventas, pedidos, logs ‚Üí chunks por per√≠odo/estado\n- **RELACIONAL**: Clientes, contactos, empleados ‚Üí chunks por entidad individual\n- **ANAL√çTICO**: M√©tricas, KPIs, reportes ‚Üí chunks por dimensi√≥n/agregaci√≥n\n- **DOCUMENTAL**: Descripciones, contenido largo ‚Üí chunks por tema/secci√≥n\n- **OTRO**: Especifica tipo y estrategia custom\n\n### 2. **C√ÅLCULO DE CAPACIDAD POR CHUNK**\nBas√°ndote en los campos y su longitud promedio:\n- **Caracteres por registro**: Estima suma de campos relevantes\n- **Registros por chunk**: 1500 / caracteres_por_registro\n- **Overhead de formato**: Reserva ~200 chars para headers y metadata\n- **Capacidad real**: Ajusta para el peor caso (registros m√°s largos)\n\n### 3. **ESTRATEGIA DE CHUNKING √ìPTIMA**\n\n#### TIPOS DE CHUNKS DISPONIBLES:\n- **INDIVIDUAL**: 1 registro = 1 chunk (para entidades complejas >500 chars)\n- **AGRUPADO**: N registros relacionados (categor√≠a, marca, per√≠odo)\n- **COMPARATIVO**: Top-N o destacados (mejores, m√°s vendidos, cr√≠ticos)\n- **RESUMEN**: Agregaciones estad√≠sticas (promedios, totales, tendencias)\n- **H√çBRIDO**: Combinaci√≥n seg√∫n densidad de datos\n\n#### DECISI√ìN DE AGRUPACI√ìN:\n- Si registros <100 chars ‚Üí AGRUPADO obligatorio\n- Si registros >500 chars ‚Üí INDIVIDUAL o m√°x 2-3 por chunk\n- Si hay jerarqu√≠as naturales ‚Üí AGRUPADO por nivel superior\n- Si hay pocos registros totales (<50) ‚Üí considera UN SOLO CHUNK\n\n### 4. **OPTIMIZACI√ìN SEM√ÅNTICA Y MANEJO DE PRECIOS**\n\n#### ENRIQUECIMIENTO DE CONTENIDO:\n- **Contexto del dominio**: T√©rminos que un usuario esperar√≠a encontrar\n- **Expansi√≥n sem√°ntica**: Sin√≥nimos, variaciones, traducciones comunes\n- **Preguntas impl√≠citas**: \"¬øCu√°l es...?\", \"¬øD√≥nde encontrar...?\"\n- **Casos de uso**: Frases de b√∫squeda t√≠picas del dominio\n\n#### INTEGRACI√ìN DE PRECIOS (SI APLICA):\n- **Formato de precio**: CADA item debe mostrar SU precio individual\n- **Ejemplo correcto**: \"iPhone 14 $24,999, Samsung S23 $19,999, Xiaomi $8,999\"\n- **Ejemplo incorrecto**: \"Smartphones desde $8,999 hasta $24,999\"\n- **Sin precio**: Indicar claramente \"Producto X (consultar precio)\"\n\n#### ESTRUCTURA DEL CHUNK:\n```\n[ENCABEZADO con tipo y contexto - 50-100 chars]\n[CONTENIDO PRINCIPAL con items y precios individuales - 800-1200 chars]\n[METADATA INLINE con rangos de precio si aplica - 100-200 chars]\n[PALABRAS CLAVE de b√∫squeda - 50-100 chars]\n```\n\n### 5. **METADATA Y FILTRADO**\n\n#### CLASIFICACI√ìN DE CAMPOS:\n- **CONTENIDO PRIMARIO**: Informaci√≥n que responde queries directas\n- **CONTENIDO CONTEXTUAL**: Enriquece pero no es b√∫squeda principal  \n- **METADATA PURA**: Solo para filtros, no para matching sem√°ntico\n- **IGNORAR**: Campos t√©cnicos sin valor de b√∫squeda\n\n#### METADATA ESPEC√çFICA DE PRECIOS (SI DETECTADOS):\n- **price_range**: Definir categor√≠as apropiadas (economico/medio/premium/lujo)\n- **has_price**: Indicador booleano de disponibilidad\n- **min_price/max_price**: Rangos num√©ricos para filtrado\n- **Segmentaci√≥n**: Definir cortes de precio relevantes al dominio\n\n#### TRANSFORMACIONES RECOMENDADAS:\n- Rangos num√©ricos ‚Üí categor√≠as textuales (barato/medio/caro)\n- Fechas ‚Üí per√≠odos relativos (este mes, trimestre pasado)\n- Booleanos ‚Üí frases naturales (\"disponible\" vs true)\n- C√≥digos ‚Üí nombres descriptivos\n- **Precios ‚Üí Formato consistente** ($X,XXX.XX MXN)\n\n## DATOS A ANALIZAR\n{{ $json.analisisCompleto.reporteTexto }}\n\n## INFORMACI√ìN ADICIONAL DISPONIBLE\n- **Campos detectados**: {{ $json.campos }}\n- **Campos de precio identificados**: {{ $json.analisisCompleto.resumen.camposIdentificados.precios }}\n- **Campos categ√≥ricos**: {{ $json.analisisCompleto.resumen.camposCategoricos }}\n- **Total de registros**: {{ $json.analisisCompleto.resumen.totalRegistros }}\n\n## FORMATO DE RESPUESTA REQUERIDO\n\n### SECCI√ìN 1: DIAGN√ìSTICO DEL DATASET (75-100 palabras)\n- Tipo de dataset: [CATEGOR√çA]\n- Volumen: [total registros] registros, ~[X] chars promedio c/u\n- Entidad principal: [qu√© representa cada fila]\n- Complejidad: [simple/media/compleja] por [raz√≥n]\n- Reto principal: [qu√© dificulta el chunking]\n\n### SECCI√ìN 2: ESTRATEGIA DE IMPLEMENTACI√ìN (150-200 palabras)\n```yaml\nCONFIGURACI√ìN:\n  tipo_chunk: [TIPO] # con justificaci√≥n basada en c√°lculos\n  registros_por_chunk: [N] # basado en l√≠mite 1500 chars\n  agrupaci√≥n_primaria: [campo] # el m√°s selectivo\n  agrupaci√≥n_secundaria: [campo] # si aplica\n  \nC√ÅLCULOS:\n  chars_por_registro: [promedio estimado]\n  overhead_formato: [reservado para structure]\n  capacidad_efectiva: [registros que caben]\n  total_chunks_estimados: [cantidad final]\n\nCONTENIDO_CHUNK:\n  l√≠nea_1: \"TIPO: [tipo] | [contexto]\"\n  l√≠nea_2: \"[campo_principal]: [valor]\"\n  contenido_principal: # Debe incluir precios si existen\n    - Sin precios: \"[item1], [item2], [item3]\"\n    - Con precios: \"[item1] $[precio1], [item2] $[precio2], [item3] $[precio3]\"\n  metadata_inline: \"[filtro1]: [valor] | [filtro2]: [valor]\"\n  keywords: \"[t√©rminos de b√∫squeda relevantes]\"\n\nMANEJO_DE_PRECIOS: # SI SE DETECTAN CAMPOS DE PRECIO\n  campo_precio_principal: [campo detectado]\n  formato_display: \"individual_por_item\" # NO rangos generales\n  categorizaci√≥n: [economico: <X, medio: X-Y, premium: >Y]\n  metadata_precio: \n    - price_range: \"[categoria]\" # string\n    - has_price: true/false # booleano\n    - min_price: [n√∫mero] # n√∫mero\n    - max_price: [n√∫mero] # n√∫mero\n```\n\n### SECCI√ìN 3: INSTRUCCIONES DE C√ìDIGO (100-125 palabras)\nPseudoc√≥digo espec√≠fico para el implementador:\n```javascript\n// 1. Agrupar registros por [campo]\n// 2. Para cada grupo:\n//    - Limitar a [N] registros m√°ximo\n//    - Construir texto con formato:\n//      * Encabezado: [formato espec√≠fico]\n//      * Contenido: [campos] unidos con [separador]\n//    - Validar longitud < 1500\n//    - Si excede, dividir en sub-chunks\n// 3. Generar metadata objeto con: {campos}\n// 4. Casos especiales: [manejo de nulls, etc]\n```\n\n## PRINCIPIOS GU√çA\n1. **Pragmatismo**: Si el dataset es peque√±o (<30 registros), un solo chunk puede ser √≥ptimo\n2. **Densidad**: Maximiza informaci√≥n √∫til por car√°cter\n3. **Naturalidad**: Los chunks deben leerse como texto coherente\n4. **Recuperabilidad**: Optimiza para las queries m√°s probables del dominio\n5. **Implementabilidad**: Cada instrucci√≥n debe ser ejecutable sin ambig√ºedad\n\n---\n\nIMPORTANTE: Tu an√°lisis determinar√° la calidad de b√∫squeda de todo el sistema. S√© espec√≠fico, pragm√°tico y siempre respeta el l√≠mite de 1500 caracteres.",
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        1520,
        2928
      ],
      "id": "a94b5798-a3c0-4eca-8298-173760581d6c",
      "name": "LLM ANALISTA"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=# PROMPT PARA LLM - GENERADOR UNIVERSAL DE C√ìDIGO RAG\n\n## CONTEXTO\nEres un experto en sistemas RAG (Retrieval Augmented Generation) y necesitas generar c√≥digo JavaScript para n8n que convierta CUALQUIER tipo de datos CSV en chunks optimizados para vectorizaci√≥n y consultas de LLM.\n\n## ESTRATEGIA DEFINIDA POR EL ANALISTA\n{{ $json.text }}\n\n## TAREA\nGenera c√≥digo JavaScript completo y funcional que:\n1. Procese datos CSV usando `const items = $('Extract from File').all();`\n2. Implemente EXACTAMENTE la estrategia definida por el analista\n3. Se adapte autom√°ticamente a cualquier estructura de datos\n4. Maneje campos de precio si existen\n5. Genere chunks y metadata seg√∫n las especificaciones del analista\n\n## CAMPOS DISPONIBLES EN EL CSV\n{{ $('Transformador de CSV').item.json.campos }}\n\n## ESPECIFICACIONES T√âCNICAS UNIVERSALES\n\n### ESTRUCTURA BASE OBLIGATORIA:\n```javascript\nconst items = $('Extract from File').all(); \n// Tu c√≥digo aqu√≠\nreturn chunks.map(chunk => ({ json: chunk }));\n```\n\n### FORMATO DE CHUNK UNIVERSAL:\n```javascript\n{\n  id: \"chunk_X\",\n  type: \"[tipo_definido_por_analista]\",\n  content: \"[texto seg√∫n formato del analista]\",\n  metadata: {\n    // Campos definidos en MANEJO_DE_PRECIOS o METADATA del analista\n    // Siempre incluir:\n    timestamp: new Date().toISOString(),\n    chunk_size: content.length,\n    record_count: [n√∫mero de registros en el chunk]\n  }\n}\n```\n\n## INSTRUCCIONES DE IMPLEMENTACI√ìN DIN√ÅMICA\n\n### 1. EXTRAER PAR√ÅMETROS DE LA ESTRATEGIA\nLee cuidadosamente la estrategia del analista y extrae:\n- `tipo_chunk` de CONFIGURACI√ìN\n- `registros_por_chunk` o `capacidad_efectiva` \n- `agrupaci√≥n_primaria` y `agrupaci√≥n_secundaria` si existen\n- Formato espec√≠fico de `CONTENIDO_CHUNK`\n- Campos de `MANEJO_DE_PRECIOS` si aplica\n- Instrucciones espec√≠ficas de la SECCI√ìN 3\n\n### 2. DETECCI√ìN AUTOM√ÅTICA DE CAMPOS\n```javascript\n// Mapeo universal de tipos de campos\nconst tiposCampos = {\n  identificadores: ['id', '_id', 'code', 'sku', 'key', 'identifier'],\n  nombres: ['name', 'title', 'nombre', 'product_name', 'item_name'],\n  precios: ['price', 'cost', 'precio', 'value', 'amount', 'sale_price'],\n  cantidades: ['quantity', 'stock', 'count', 'inventory', 'cantidad'],\n  categorias: ['category', 'type', 'class', 'group', 'tipo'],\n  descripciones: ['description', 'details', 'info', 'about', 'summary'],\n  estados: ['status', 'available', 'active', 'enabled', 'is_'],\n  fechas: ['date', 'created', 'updated', 'fecha', '_at'],\n  calificaciones: ['rating', 'score', 'review', 'stars', 'calificacion']\n};\n```\n\n### 3. ADAPTACI√ìN AL TIPO DE DATASET\nBas√°ndote en el \"Tipo de dataset\" del DIAGN√ìSTICO:\n- **CAT√ÅLOGO**: Agrupar por categor√≠a/tipo, incluir precios si existen\n- **TRANSACCIONAL**: Agrupar por per√≠odo/estado, incluir totales\n- **RELACIONAL**: Chunks individuales por entidad\n- **ANAL√çTICO**: Agrupar por dimensiones, incluir m√©tricas\n- **DOCUMENTAL**: Chunks por secciones tem√°ticas\n- **OTRO**: Seguir instrucciones espec√≠ficas del analista\n\n### 4. IMPLEMENTACI√ìN DEL FORMATO DE CONTENIDO\nUsa EXACTAMENTE el formato definido en `CONTENIDO_CHUNK` de la estrategia:\n- Si especifica l√≠neas numeradas, resp√©talas\n- Si incluye ejemplos de formato, s√≠guelos literalmente\n- Si menciona separadores espec√≠ficos (\", \" o \" | \"), √∫salos\n\n**IMPORTANTE**: El contenido del chunk debe incluir TODAS las l√≠neas especificadas en CONTENIDO_CHUNK:\n- l√≠nea_1, l√≠nea_2, contenido_principal, metadata_inline, keywords\n- Estas son PARTE DEL CONTENIDO, no van en el objeto metadata\n- El contenido es un string de m√∫ltiples l√≠neas con saltos de l√≠nea (\\n)\n\n**EJEMPLO DE CONTENIDO CORRECTO**:\n```\nTIPO: CATEGOR√çA | Productos de Prote√≠na\ncategory: Prote√≠na\nWhey Gold $65.99, Creatine Pure $29.99, BCAA Elite $45.50, Protein Bar $24.99\ncategory: Prote√≠na | available: true\nkeywords: productos, prote√≠na, precio, comprar\n```\n\n### 5. MANEJO INTELIGENTE DE PRECIOS (SI APLICA)\nSolo si el analista detect√≥ campos de precio:\n```javascript\n// Usar el campo definido en campo_precio_principal\n// Aplicar la categorizaci√≥n exacta definida en MANEJO_DE_PRECIOS\n// Formatear seg√∫n las instrucciones (individual_por_item, etc.)\n```\n\n### 6. VALIDACIONES UNIVERSALES\n```javascript\n// MAXIMIZAR uso del espacio: intentar incluir tantos registros como sea posible\n// Solo reducir si excede 1500 caracteres\nif (content.length > 1500) {\n  // Reducir n√∫mero de registros EN INCREMENTOS, no uno por uno\n  // Ejemplo: si tienes 6 y no caben, prueba con 4, no con 5\n}\nif (chunks.length >= 100) {\n  // Detener procesamiento\n  break; // usar break, no return\n}\n```\n\n**OPTIMIZACI√ìN DE AGRUPACI√ìN**:\n- SIEMPRE intenta llenar chunks al m√°ximo permitido\n- Si un grupo tiene pocos items, comb√≠nalo con el siguiente\n- Objetivo: minimizar n√∫mero total de chunks maximizando contenido por chunk\n\n## PLANTILLA DE C√ìDIGO ADAPTATIVA\n\n```javascript\nconst items = $('Extract from File').all();\nconst chunks = [];\nlet chunkId = 1;\n\n// PASO 1: Identificar campos disponibles\nconst campos = items.length > 0 ? Object.keys(items[0].json) : [];\n\n// PASO 2: Detectar tipos de campos autom√°ticamente\nfunction detectarTipoCampo(nombreCampo) {\n  const campoLower = nombreCampo.toLowerCase();\n  // [Implementar detecci√≥n basada en tiposCampos]\n}\n\n// PASO 3: Extraer configuraci√≥n de la estrategia\n// [IMPORTANTE: Debes parsear la estrategia del analista aqu√≠]\n// Ejemplo: Si el analista dice \"agrupaci√≥n_primaria: category\"\n// entonces buscar el campo que sea tipo 'categoria'\n\n// PASO 4: Implementar l√≥gica de chunking seg√∫n tipo_chunk\n// - Si es AGRUPADO: agrupar por campo primario\n// - Si es INDIVIDUAL: un registro por chunk\n// - Si es COMPARATIVO: seleccionar top N\n// - Si es RESUMEN: crear agregaciones\n\n// PASO 5: Generar chunks seg√∫n formato especificado\n// CR√çTICO: El content debe ser un string que incluya TODAS las l√≠neas de CONTENIDO_CHUNK:\n// l√≠nea_1 + \"\\n\" + l√≠nea_2 + \"\\n\" + contenido_principal + \"\\n\" + metadata_inline + \"\\n\" + keywords\n\n// PASO 6: Calcular metadata seg√∫n especificaciones\n// La metadata del objeto chunk es DIFERENTE al metadata_inline del contenido\n// metadata_inline va DENTRO del content como texto\n// metadata del chunk va en el objeto metadata\n\n// PASO 7: Optimizar agrupaci√≥n\n// Si un grupo tiene menos items que capacidad_efectiva, intentar combinar con siguiente grupo\n// Objetivo: chunks llenos, no chunks peque√±os\n\nreturn chunks.map(chunk => ({ json: chunk }));\n```\n\n## PRINCIPIOS DE ADAPTACI√ìN\n\n1. **FIDELIDAD A LA ESTRATEGIA**: Implementa EXACTAMENTE lo que dice el analista\n2. **DETECCI√ìN INTELIGENTE**: Identifica campos por patrones si no coinciden exactamente\n3. **ROBUSTEZ**: Maneja casos edge (campos nulos, formatos inesperados)\n4. **UNIVERSALIDAD**: El c√≥digo debe funcionar con CUALQUIER CSV\n5. **VALIDACI√ìN**: Siempre verificar l√≠mites antes de crear chunks\n\n## MANEJO DE CASOS ESPECIALES\n\n- **Sin categor√≠as**: Usar agrupaci√≥n alternativa o chunks secuenciales\n- **Sin precios**: Omitir secciones de precio completamente\n- **Pocos registros**: Considerar un √∫nico chunk si < 10 registros\n- **Muchos campos**: Priorizar seg√∫n importancia mencionada por analista\n- **Datos largos**: Truncar inteligentemente respetando l√≠mites\n- **Valores booleanos**: \n  - `true/false` ‚Üí mostrar como \"disponible/no disponible\" o \"s√≠/no\"\n  - `1/0` ‚Üí interpretar como true/false\n  - Para `is_available`: true = \"disponible\", false = \"no disponible\"\n- **Optimizaci√≥n de espacio**:\n  - SIEMPRE intentar llenar chunks cerca del l√≠mite\n  - Combinar grupos peque√±os antes de crear chunks parciales\n  - Preferir 20 chunks llenos sobre 70 chunks peque√±os\n\n## IMPORTANTE\n- El c√≥digo debe ser 100% funcional y ejecutable\n- Debe adaptarse a CUALQUIER estructura de CSV\n- Debe seguir EXACTAMENTE la estrategia del analista\n- NO uses placeholders o comentarios \"// implementar aqu√≠\"\n- Maneja TODOS los casos edge posibles\n\n## REGLAS CR√çTICAS\n1. **NO incluyas marcadores de c√≥digo** como ```javascript\n2. **Comienza directamente** con: const items = $('Extract from File').all();\n3. **Implementa la estrategia EXACTA** del analista\n4. **Adapta autom√°ticamente** a los campos disponibles\n5. **Genera c√≥digo COMPLETO** sin placeholders\n6. **Incluye TODA la l√≥gica** necesaria\n7. **Responde √öNICAMENTE con c√≥digo JavaScript**\n\nGENERA EL C√ìDIGO JAVASCRIPT COMPLETO AHORA.",
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2016,
        2928
      ],
      "id": "fb1d3048-e51e-4c3d-8e69-e2ecd6b5b074",
      "name": "LLM CODIGO"
    },
    {
      "parameters": {
        "jsCode": "// Obtener el c√≥digo generado por el LLM desde el nodo anterior\nconst llmResponse = $input.first().json.text;\n\n// Limpiar y extraer el c√≥digo JavaScript\nlet generatedCode = llmResponse.trim();\n\n// Remover marcadores de c√≥digo si existen\ngeneratedCode = generatedCode.replace(/^```javascript?\\n?|```$/g, '');\n\n// Verificar que el c√≥digo comience correctamente\nif (!generatedCode.includes(\"const items = $('Extract from File').all();\")) {\n  throw new Error('C√≥digo generado no tiene la estructura esperada. Debe comenzar con: const items = $(\\'Extract from File\\').all();');\n}\n\n// Ejecutar el c√≥digo generado de forma segura\ntry {\n  // Crear el contexto necesario para la ejecuci√≥n\n  const executeChunking = () => {\n    // Aqu√≠ se ejecutar√° el c√≥digo generado\n    // El c√≥digo generado debe poder acceder a $ y otros contextos de n8n\n    \n    // Crear funci√≥n que simule el entorno de n8n\n    const mockContext = (nodeName) => {\n      if (nodeName === 'Extract from File') {\n        return {\n          all: () => $('Extract from File').all()\n        };\n      }\n      // Para otros nodos, usar el contexto real de n8n\n      return $(nodeName);\n    };\n    \n    // Reemplazar las llamadas a $ en el c√≥digo generado\n    // para usar nuestro contexto mockeado\n    let executableCode = generatedCode;\n    \n    // Reemplazar $('Extract from File') con llamadas al contexto real\n    executableCode = executableCode.replace(\n      /\\$\\('Extract from File'\\)/g, \n      \"mockContext('Extract from File')\"\n    );\n    \n    // Envolver el c√≥digo en una funci√≥n que retorne el resultado\n    const wrappedCode = `\n      const mockContext = ${mockContext.toString()};\n      ${executableCode}\n    `;\n    \n    // Ejecutar el c√≥digo usando Function constructor de forma m√°s segura\n    const executeFunction = new Function(wrappedCode + '; return chunks.map(chunk => ({ json: chunk }));');\n    return executeFunction();\n  };\n  \n  // Ejecutar y obtener resultado\n  const result = executeChunking();\n  \n  // Validar que el resultado tenga el formato esperado\n  if (!Array.isArray(result)) {\n    throw new Error('El c√≥digo generado no retorn√≥ un array v√°lido');\n  }\n  \n  // Validar estructura de chunks\n  for (let i = 0; i < Math.min(result.length, 3); i++) {\n    const chunk = result[i];\n    if (!chunk.json || !chunk.json.id || !chunk.json.content || !chunk.json.metadata) {\n      throw new Error(`Chunk ${i} no tiene la estructura esperada (id, content, metadata)`);\n    }\n  }\n  \n  // Log para debugging\n  console.log(`‚úÖ C√≥digo ejecutado exitosamente. Generados ${result.length} chunks`);\n  \n  return result;\n  \n} catch (executionError) {\n  console.error('‚ùå Error ejecutando c√≥digo generado:', executionError.message);\n  \n  // Fallback m√°s seguro: intentar ejecuci√≥n directa solo en desarrollo\n  try {\n    console.log('üîÑ Intentando ejecuci√≥n alternativa...');\n    \n    // M√©todo alternativo: eval en contexto controlado\n    const safeEval = () => {\n      // Crear las variables que el c√≥digo generado espera\n      const items = $('Extract from File').all();\n      const chunks = [];\n      let chunkId = 1;\n      \n      // Remover la primera l√≠nea del c√≥digo generado ya que definimos items arriba\n      let codeWithoutFirstLine = generatedCode.replace(/const items = \\$\\('Extract from File'\\)\\.all\\(\\);\\s*/, '');\n      \n      // Evaluar el resto del c√≥digo\n      eval(codeWithoutFirstLine);\n      \n      // Retornar el resultado esperado\n      return chunks.map(chunk => ({ json: chunk }));\n    };\n    \n    const fallbackResult = safeEval();\n    console.log(`‚ö†Ô∏è Ejecuci√≥n alternativa exitosa. Generados ${fallbackResult.length} chunks`);\n    return fallbackResult;\n    \n  } catch (fallbackError) {\n    // Si todo falla, proporcionar informaci√≥n detallada para debugging\n    const errorInfo = {\n      json: {\n        error: 'C√ìDIGO_NO_EJECUTABLE',\n        message: `No se pudo ejecutar el c√≥digo generado: ${executionError.message}`,\n        fallback_error: fallbackError.message,\n        generated_code_preview: generatedCode.substring(0, 500) + '...',\n        suggestions: [\n          'Verificar que el LLM gener√≥ c√≥digo sint√°cticamente correcto',\n          'Revisar que no hay dependencias externas no disponibles',\n          'Validar que la estructura del CSV es la esperada'\n        ]\n      }\n    };\n    \n    console.error('‚ùå Ambos m√©todos de ejecuci√≥n fallaron:', errorInfo);\n    return [errorInfo];\n  }\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2528,
        2928
      ],
      "id": "4565f428-ceaa-4120-a005-7b95de4627c8",
      "name": "Chunks"
    },
    {
      "parameters": {
        "jsCode": "// C√ìDIGO PARA NODO CODE EN N8N\n// Transforma cada item con informaci√≥n dispersa en un item con texto organizado\n\n// Configuraci√≥n - Puedes modificar estas opciones\nconst CONFIG = {\n  // Separadores para diferentes secciones\n  sectionSeparator: '\\n\\n',\n  fieldSeparator: '\\n',\n  arraySeparator: ', ',\n  \n  // Formato de salida: 'paragraph', 'structured', 'detailed'\n  outputFormat: 'structured',\n  \n  // Si incluir encabezados de secci√≥n\n  includeHeaders: true,\n  \n  // Si mostrar campos vac√≠os\n  showEmptyFields: false,\n  \n  // Campos a excluir del texto\n  excludeFields: ['timestamp'],\n  \n  // Orden de secciones (si no se especifica, usa el orden original)\n  sectionOrder: ['id', 'type', 'content', 'metadata', 'brands'],\n  \n  // Si mantener los campos originales adem√°s del texto\n  keepOriginalFields: true\n};\n\n// Funci√≥n para formatear valores seg√∫n su tipo\nfunction formatValue(key, value) {\n  if (value === null || value === undefined) {\n    return CONFIG.showEmptyFields ? `${key}: (vac√≠o)` : '';\n  }\n  \n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return CONFIG.showEmptyFields ? `${key}: (sin elementos)` : '';\n    }\n    return `${key}: ${value.join(CONFIG.arraySeparator)}`;\n  }\n  \n  if (typeof value === 'object') {\n    return formatObject(key, value);\n  }\n  \n  if (typeof value === 'boolean') {\n    return `${key}: ${value ? 'S√≠' : 'No'}`;\n  }\n  \n  if (typeof value === 'number') {\n    return `${key}: ${value}`;\n  }\n  \n  return `${key}: ${value}`;\n}\n\n// Funci√≥n para formatear objetos anidados\nfunction formatObject(parentKey, obj, level = 0) {\n  const indent = '  '.repeat(level);\n  const lines = [];\n  \n  if (CONFIG.includeHeaders && level === 0) {\n    lines.push(`${parentKey.toUpperCase()}:`);\n  }\n  \n  Object.entries(obj).forEach(([key, value]) => {\n    if (CONFIG.excludeFields.includes(key)) return;\n    \n    if (Array.isArray(value)) {\n      if (value.length > 0 || CONFIG.showEmptyFields) {\n        const formattedValue = value.length > 0 ? value.join(CONFIG.arraySeparator) : '(sin elementos)';\n        lines.push(`${indent}${key}: ${formattedValue}`);\n      }\n    } else if (typeof value === 'object' && value !== null) {\n      lines.push(formatObject(key, value, level + 1));\n    } else {\n      if (value !== null && value !== undefined && value !== '' || CONFIG.showEmptyFields) {\n        lines.push(`${indent}${key}: ${value}`);\n      }\n    }\n  });\n  \n  return lines.filter(line => line.trim()).join(CONFIG.fieldSeparator);\n}\n\n// Funci√≥n para crear texto organizado seg√∫n el formato\nfunction createOrganizedText(item) {\n  const sections = [];\n  \n  // Determinar qu√© campos procesar y en qu√© orden\n  const fieldsToProcess = CONFIG.sectionOrder.length > 0 \n    ? CONFIG.sectionOrder.filter(field => item.hasOwnProperty(field))\n    : Object.keys(item).filter(key => !CONFIG.excludeFields.includes(key));\n  \n  // Agregar campos que no est√°n en sectionOrder al final\n  const remainingFields = Object.keys(item).filter(key => \n    !CONFIG.excludeFields.includes(key) && \n    !fieldsToProcess.includes(key)\n  );\n  fieldsToProcess.push(...remainingFields);\n  \n  // Procesar cada campo\n  fieldsToProcess.forEach(key => {\n    const value = item[key];\n    const formattedSection = formatValue(key, value);\n    \n    if (formattedSection) {\n      sections.push(formattedSection);\n    }\n  });\n  \n  // Formatear seg√∫n el tipo de salida configurado\n  switch (CONFIG.outputFormat) {\n    case 'paragraph':\n      return sections.join('. ') + '.';\n      \n    case 'structured':\n      return sections.join(CONFIG.sectionSeparator);\n      \n    case 'detailed':\n      const header = `=== ITEM ${item.id || 'SIN ID'} ===`;\n      const content = sections.join(CONFIG.sectionSeparator);\n      const footer = `=== FIN DEL ITEM ===`;\n      return [header, content, footer].join(CONFIG.sectionSeparator);\n      \n    default:\n      return sections.join(CONFIG.sectionSeparator);\n  }\n}\n\n// Funci√≥n para generar un resumen del item\nfunction generateSummary(item) {\n  const summary = [];\n  \n  // Informaci√≥n b√°sica\n  if (item.id) summary.push(`ID: ${item.id}`);\n  if (item.type) summary.push(`Tipo: ${item.type}`);\n  \n  // Contar elementos importantes\n  const stats = [];\n  Object.entries(item).forEach(([key, value]) => {\n    if (Array.isArray(value) && value.length > 0) {\n      stats.push(`${value.length} ${key}`);\n    }\n  });\n  \n  if (stats.length > 0) {\n    summary.push(`Contiene: ${stats.join(', ')}`);\n  }\n  \n  return summary.join(' | ');\n}\n\n// Funci√≥n principal para procesar un item\nfunction processItem(item) {\n  try {\n    // Crear el texto organizado\n    const organizedText = createOrganizedText(item);\n    \n    // Crear el resultado\n    const result = {\n      organized_text: organizedText,\n      summary: generateSummary(item),\n      processed_at: new Date().toISOString(),\n      original_fields_count: Object.keys(item).length\n    };\n    \n    // Mantener campos originales si est√° configurado\n    if (CONFIG.keepOriginalFields) {\n      Object.entries(item).forEach(([key, value]) => {\n        if (!result.hasOwnProperty(key)) {\n          result[key] = value;\n        }\n      });\n    }\n    \n    return result;\n    \n  } catch (error) {\n    console.error('Error procesando item:', error);\n    return {\n      organized_text: 'Error al procesar la informaci√≥n de este item',\n      error_message: error.message,\n      original_item: item,\n      processed_at: new Date().toISOString()\n    };\n  }\n}\n\n// C√ìDIGO PRINCIPAL PARA N8N\ntry {\n  // Obtener todos los items de entrada\n  const inputItems = $input.all();\n  \n  // Procesar cada item individualmente\n  const processedItems = inputItems.map((item, index) => {\n    const processedData = processItem(item.json || {});\n    \n    return {\n      json: processedData,\n      pairedItem: item.pairedItem || index\n    };\n  });\n  \n  // Retornar todos los items procesados (mismo n√∫mero que la entrada)\n  return processedItems;\n  \n} catch (error) {\n  console.error('Error general en el procesamiento:', error);\n  \n  // En caso de error, retornar informaci√≥n del error\n  return [{\n    json: {\n      error: 'Error general en el procesamiento',\n      error_message: error.message,\n      total_input_items: $input.all().length,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n/*\nEJEMPLOS DE CONFIGURACI√ìN:\n\n// CONFIGURACI√ìN 1: Formato p√°rrafo simple\nconst CONFIG = {\n  sectionSeparator: '. ',\n  fieldSeparator: ', ',\n  arraySeparator: ', ',\n  outputFormat: 'paragraph',\n  includeHeaders: false,\n  showEmptyFields: false,\n  excludeFields: ['timestamp'],\n  sectionOrder: [],\n  keepOriginalFields: false\n};\n\n// CONFIGURACI√ìN 2: Formato estructurado detallado\nconst CONFIG = {\n  sectionSeparator: '\\n\\n',\n  fieldSeparator: '\\n',\n  arraySeparator: ' | ',\n  outputFormat: 'detailed',\n  includeHeaders: true,\n  showEmptyFields: true,\n  excludeFields: [],\n  sectionOrder: ['id', 'type', 'content', 'metadata', 'brands'],\n  keepOriginalFields: true\n};\n\n// CONFIGURACI√ìN 3: Formato compacto\nconst CONFIG = {\n  sectionSeparator: ' // ',\n  fieldSeparator: ', ',\n  arraySeparator: '; ',\n  outputFormat: 'structured',\n  includeHeaders: false,\n  showEmptyFields: false,\n  excludeFields: ['timestamp', 'metadata'],\n  sectionOrder: ['content', 'brands'],\n  keepOriginalFields: false\n};\n*/"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2688,
        2928
      ],
      "id": "e9358b72-9d72-4b29-a9a0-17bb0fd3794f",
      "name": "Agrupar Items"
    },
    {
      "parameters": {
        "jsCode": "// ANALIZADOR PROFUNDO DE CSV - VERSI√ìN CORREGIDA\nconst rows = $input.all();\nconst totalRows = rows.length;\n\n// Inicializar estructura de an√°lisis\nconst camposAnalisis = {};\nconst patronesDetectados = {\n  identificadores: [],\n  nombres: [],\n  precios: [],\n  cantidades: [],\n  categorias: [],\n  descripciones: [],\n  calificaciones: [],\n  estados: [],\n  fechas: [],\n  urls: [],\n  emails: [],\n  marcas: [],\n  medidas: [] // NUEVO: para serving_size, dimensions, etc.\n};\n\n// Funci√≥n mejorada para validar si es fecha\nconst esFechaValida = (valor) => {\n  if (typeof valor !== 'string') return false;\n  \n  // Patrones comunes de fecha\n  const patronesFecha = [\n    /^\\d{4}-\\d{2}-\\d{2}/, // YYYY-MM-DD\n    /^\\d{2}\\/\\d{2}\\/\\d{4}/, // DD/MM/YYYY o MM/DD/YYYY\n    /^\\d{2}-\\d{2}-\\d{4}/, // DD-MM-YYYY\n    /^\\d{4}\\/\\d{2}\\/\\d{2}/, // YYYY/MM/DD\n  ];\n  \n  // Verificar si coincide con alg√∫n patr√≥n\n  const coincidePatron = patronesFecha.some(patron => patron.test(valor));\n  if (!coincidePatron) return false;\n  \n  // Intentar parsear como fecha\n  const fecha = new Date(valor);\n  return !isNaN(fecha.getTime()) && fecha.getFullYear() > 1900 && fecha.getFullYear() < 2100;\n};\n\n// Funci√≥n para detectar si es una medida/porci√≥n\nconst esMedidaOPorcion = (valores) => {\n  const muestras = valores.filter(v => v !== null && v !== undefined && v !== '').slice(0, 20);\n  \n  // Patrones de medidas comunes\n  const patronesMedida = [\n    /^\\d+\\s*(g|kg|mg|ml|l|oz|lb|tabletas?|c√°psulas?|caps?|pills?|scoops?|servings?|sobres?|porciones?)$/i,\n    /^\\d+\\s*-\\s*\\d+\\s*(g|kg|mg|ml|l|oz|lb|tabletas?|c√°psulas?|caps?|pills?|scoops?|servings?|sobres?|porciones?)$/i,\n    /^(one|two|three|four|five|\\d+)\\s+(tablet|capsule|cap|pill|scoop|serving|sobre|porcion)/i\n  ];\n  \n  // Verificar si la mayor√≠a coincide con patrones de medida\n  const coincidencias = muestras.filter(v => \n    typeof v === 'string' && patronesMedida.some(patron => patron.test(v.trim()))\n  );\n  \n  return coincidencias.length > muestras.length * 0.5;\n};\n\n// Funci√≥n mejorada de detecci√≥n de tipo de contenido\nconst detectarTipoContenido = (campo, valores) => {\n  const campoLower = campo.toLowerCase();\n  const muestras = valores.filter(v => v !== null && v !== undefined && v !== '').slice(0, 20);\n  \n  // PRIORIDAD 1: Detectar por nombre de campo (mejorado)\n  \n  // NUEVO: Detectar medidas/porciones ANTES que precios\n  if (campoLower.match(/\\b(serving|portion|dose|dosage|size|medida|porcion|dosis)\\b/) ||\n      campoLower.match(/\\b(serving_size|portion_size|dose_size)\\b/)) {\n    return 'medida';\n  }\n  \n  // Identificadores\n  if (campoLower.match(/\\b(^id$|_id$|^id_|_id_|code|sku|key|identifier)\\b/)) {\n    return 'identificador';\n  }\n  \n  // Nombres y t√≠tulos\n  if (campoLower.match(/\\b(name|title|nombre|product_name|item_name)\\b/)) {\n    return 'nombre';\n  }\n  \n  // Precios - MEJORADO: excluir expl√≠citamente serving_size y similares\n  if (campoLower.match(/\\b(price|cost|precio|amount|total|value)\\b/) && \n      !campoLower.match(/\\b(review|num_|count|serving|portion|dose|size)\\b/)) {\n    return 'precio';\n  }\n  \n  // Cantidades y conteos\n  if (campoLower.match(/\\b(quantity|stock|inventory|cantidad|count|num_|number_of)\\b/) ||\n      campoLower.match(/\\b(num_reviews|review_count|total_reviews)\\b/)) {\n    return 'cantidad';\n  }\n  \n  // Categor√≠as\n  if (campoLower.match(/\\b(category|categories|type|clase|group|tipo)\\b/)) {\n    return 'categoria';\n  }\n  \n  // Descripciones\n  if (campoLower.match(/\\b(description|details|info|about|summary)\\b/)) {\n    return 'descripcion';\n  }\n  \n  // Calificaciones\n  if (campoLower.match(/\\b(rating|score|stars|review|calificacion|puntuacion)\\b/) &&\n      !campoLower.match(/\\b(num_|count|total)\\b/)) {\n    return 'calificacion';\n  }\n  \n  // Estados\n  if (campoLower.match(/\\b(status|state|available|active|enabled|is_)\\b/)) {\n    return 'estado';\n  }\n  \n  // Fechas\n  if (campoLower.match(/\\b(date|time|created|updated|modified|fecha|_at$)\\b/)) {\n    return 'fecha';\n  }\n  \n  // Marcas\n  if (campoLower.match(/\\b(brand|marca|manufacturer|company)\\b/)) {\n    return 'marca';\n  }\n  \n  // URLs\n  if (campoLower.match(/\\b(url|link|website|site)\\b/)) {\n    return 'url';\n  }\n  \n  // Emails\n  if (campoLower.match(/\\b(email|mail|correo|contact)\\b/)) {\n    return 'email';\n  }\n  \n  // PRIORIDAD 2: Detectar por contenido si no se detect√≥ por nombre\n  if (muestras.length > 0) {\n    // NUEVO: Verificar si son medidas/porciones\n    if (esMedidaOPorcion(muestras)) {\n      return 'medida';\n    }\n    \n    // Verificar si son URLs\n    if (muestras.every(v => typeof v === 'string' && v.match(/^https?:\\/\\//))) {\n      return 'url';\n    }\n    \n    // Verificar si son emails\n    if (muestras.every(v => typeof v === 'string' && v.match(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/))) {\n      return 'email';\n    }\n    \n    // Verificar si son fechas (mejorado)\n    const todasFechas = muestras.every(v => esFechaValida(v));\n    if (todasFechas) {\n      return 'fecha';\n    }\n    \n    // Verificar si son identificadores (n√∫meros enteros secuenciales o c√≥digos)\n    const todosEnteros = muestras.every(v => Number.isInteger(Number(v)));\n    const valoresNumericos = muestras.map(v => Number(v)).filter(n => !isNaN(n));\n    if (todosEnteros && valoresNumericos.length > 0) {\n      const min = Math.min(...valoresNumericos);\n      const max = Math.max(...valoresNumericos);\n      // Si parece una secuencia de IDs\n      if (min >= 0 && max < 1000000 && (max - min) < muestras.length * 100) {\n        // Verificar si el campo no fue ya clasificado como cantidad\n        if (!campoLower.match(/\\b(stock|quantity|count|num_)\\b/)) {\n          return 'identificador';\n        }\n      }\n    }\n    \n    // Verificar si son precios (n√∫meros con hasta 2 decimales)\n    // MEJORADO: Excluir si contienen unidades de medida\n    const todosPreciosValidos = muestras.every(v => {\n      const valorStr = v.toString();\n      // Excluir si contiene unidades de medida\n      if (valorStr.match(/\\b(g|kg|mg|ml|l|oz|lb|tabletas?|c√°psulas?|caps?|pills?|scoops?|servings?)\\b/i)) {\n        return false;\n      }\n      const num = parseFloat(v);\n      if (isNaN(num)) return false;\n      const decimales = valorStr.split('.')[1];\n      return !decimales || decimales.length <= 2;\n    });\n    \n    if (todosPreciosValidos && muestras.some(v => v.toString().includes('.'))) {\n      return 'precio';\n    }\n    \n    // Verificar si son cantidades (enteros positivos)\n    if (todosEnteros && valoresNumericos.every(n => n >= 0)) {\n      return 'cantidad';\n    }\n    \n    // Verificar si son calificaciones (n√∫meros entre 0-5 o 0-10)\n    const todosEnRango = valoresNumericos.every(n => n >= 0 && n <= 10);\n    const tieneDecimales = muestras.some(v => v.toString().includes('.'));\n    if (todosEnRango && tieneDecimales && valoresNumericos.length > 0) {\n      const maxVal = Math.max(...valoresNumericos);\n      if (maxVal <= 5 || maxVal === 10) {\n        return 'calificacion';\n      }\n    }\n    \n    // Verificar si son booleanos o estados\n    const estadosValidos = ['true','false','yes','no','si','no','1','0','active','inactive','available','unavailable'];\n    if (muestras.every(v => estadosValidos.includes(v.toString().toLowerCase()))) {\n      return 'estado';\n    }\n  }\n  \n  return 'general';\n};\n\n// Analizar cada campo\nrows.forEach(({ json }, index) => {\n  Object.entries(json).forEach(([campo, valor]) => {\n    // Inicializar estructura para el campo si no existe\n    if (!camposAnalisis[campo]) {\n      camposAnalisis[campo] = {\n        nombre: campo,\n        tiposJS: new Set(),\n        valoresUnicos: new Set(),\n        longitudPromedio: 0,\n        longitudMaxima: 0,\n        longitudMinima: Infinity,\n        ejemplos: [],\n        nulos: 0,\n        vacios: 0,\n        patrones: new Set(),\n        rangoNumerico: { min: Infinity, max: -Infinity },\n        tipoContenido: null,\n        frecuenciaLlenado: 0\n      };\n    }\n    \n    const analisis = camposAnalisis[campo];\n    \n    // Analizar valor\n    if (valor === null || valor === undefined) {\n      analisis.nulos++;\n    } else if (valor === '') {\n      analisis.vacios++;\n    } else {\n      analisis.frecuenciaLlenado++;\n      \n      // Tipo JavaScript\n      analisis.tiposJS.add(typeof valor);\n      \n      // Valores √∫nicos (limitar a 100 para memoria)\n      if (analisis.valoresUnicos.size < 100) {\n        analisis.valoresUnicos.add(valor);\n      }\n      \n      // Ejemplos (m√°ximo 5, diversos)\n      if (analisis.ejemplos.length < 5) {\n        const valorStr = String(valor);\n        if (!analisis.ejemplos.some(e => String(e) === valorStr)) {\n          analisis.ejemplos.push(valor);\n        }\n      }\n      \n      // An√°lisis de strings\n      if (typeof valor === 'string') {\n        const longitud = valor.length;\n        analisis.longitudPromedio += longitud;\n        analisis.longitudMaxima = Math.max(analisis.longitudMaxima, longitud);\n        analisis.longitudMinima = Math.min(analisis.longitudMinima, longitud);\n        \n        // Detectar patrones\n        if (valor.match(/^\\d+$/)) analisis.patrones.add('solo_digitos');\n        if (valor.match(/^[A-Z0-9]+$/)) analisis.patrones.add('mayusculas_numeros');\n        if (valor.match(/@/)) analisis.patrones.add('contiene_arroba');\n        if (valor.match(/https?:\\/\\//)) analisis.patrones.add('contiene_url');\n        if (valor.match(/^\\$?\\d+\\.?\\d*$/)) analisis.patrones.add('formato_precio');\n        if (esFechaValida(valor)) analisis.patrones.add('formato_fecha');\n        // NUEVO: Detectar formato de medida\n        if (valor.match(/^\\d+\\s*(g|kg|mg|ml|l|oz|lb|tabletas?|c√°psulas?|caps?|pills?|scoops?|servings?|sobres?|porciones?)$/i)) {\n          analisis.patrones.add('formato_medida');\n        }\n      }\n      \n      // An√°lisis num√©rico\n      const num = Number(valor);\n      if (!isNaN(num) && valor !== '') {\n        analisis.rangoNumerico.min = Math.min(analisis.rangoNumerico.min, num);\n        analisis.rangoNumerico.max = Math.max(analisis.rangoNumerico.max, num);\n      }\n    }\n  });\n});\n\n// Calcular estad√≠sticas finales y clasificar campos\nconst camposFinales = Object.entries(camposAnalisis).map(([campo, analisis]) => {\n  // Calcular longitud promedio\n  if (analisis.frecuenciaLlenado > 0) {\n    analisis.longitudPromedio = analisis.longitudPromedio / analisis.frecuenciaLlenado;\n  }\n  \n  // Calcular porcentaje de completitud\n  const completitud = (analisis.frecuenciaLlenado / totalRows) * 100;\n  \n  // Determinar tipo de contenido\n  const tipoContenido = detectarTipoContenido(campo, Array.from(analisis.valoresUnicos));\n  analisis.tipoContenido = tipoContenido;\n  \n  // Agregar a patrones detectados\n  switch(tipoContenido) {\n    case 'identificador': patronesDetectados.identificadores.push(campo); break;\n    case 'nombre': patronesDetectados.nombres.push(campo); break;\n    case 'precio': patronesDetectados.precios.push(campo); break;\n    case 'cantidad': patronesDetectados.cantidades.push(campo); break;\n    case 'categoria': patronesDetectados.categorias.push(campo); break;\n    case 'descripcion': patronesDetectados.descripciones.push(campo); break;\n    case 'calificacion': patronesDetectados.calificaciones.push(campo); break;\n    case 'estado': patronesDetectados.estados.push(campo); break;\n    case 'fecha': patronesDetectados.fechas.push(campo); break;\n    case 'marca': patronesDetectados.marcas.push(campo); break;\n    case 'medida': patronesDetectados.medidas.push(campo); break;\n  }\n  \n  // Determinar si es categ√≥rico\n  const esCategorico = analisis.valoresUnicos.size < 50 && \n                      analisis.valoresUnicos.size < (totalRows * 0.5) &&\n                      tipoContenido !== 'identificador' &&\n                      tipoContenido !== 'nombre';\n  \n  return {\n    campo: campo,\n    tipoContenido: tipoContenido,\n    tiposJavaScript: Array.from(analisis.tiposJS),\n    completitud: completitud.toFixed(1) + '%',\n    valoresUnicos: analisis.valoresUnicos.size,\n    esCategorico: esCategorico,\n    ejemplos: analisis.ejemplos.slice(0, 3),\n    estadisticas: {\n      nulos: analisis.nulos,\n      vacios: analisis.vacios,\n      llenos: analisis.frecuenciaLlenado\n    },\n    ...(analisis.longitudPromedio > 0 && {\n      longitudTexto: {\n        promedio: Math.round(analisis.longitudPromedio),\n        minima: analisis.longitudMinima === Infinity ? 0 : analisis.longitudMinima,\n        maxima: analisis.longitudMaxima\n      }\n    }),\n    ...(analisis.rangoNumerico.min !== Infinity && {\n      rangoNumerico: {\n        minimo: analisis.rangoNumerico.min,\n        maximo: analisis.rangoNumerico.max\n      }\n    }),\n    patrones: Array.from(analisis.patrones)\n  };\n}).sort((a, b) => a.campo.localeCompare(b.campo));\n\n// Generar resumen ejecutivo\nconst resumenEjecutivo = {\n  totalRegistros: totalRows,\n  totalCampos: camposFinales.length,\n  camposIdentificados: {\n    identificadores: patronesDetectados.identificadores,\n    nombres: patronesDetectados.nombres,\n    precios: patronesDetectados.precios,\n    cantidades: patronesDetectados.cantidades,\n    categorias: patronesDetectados.categorias,\n    descripciones: patronesDetectados.descripciones,\n    calificaciones: patronesDetectados.calificaciones,\n    estados: patronesDetectados.estados,\n    fechas: patronesDetectados.fechas,\n    marcas: patronesDetectados.marcas,\n    medidas: patronesDetectados.medidas\n  },\n  camposCategoricos: camposFinales.filter(c => c.esCategorico).map(c => c.campo),\n  camposNumericos: camposFinales.filter(c => c.rangoNumerico).map(c => c.campo),\n  camposTextoLargo: camposFinales.filter(c => c.longitudTexto?.maxima > 100).map(c => c.campo),\n  completitudPromedio: (camposFinales.reduce((acc, c) => acc + parseFloat(c.completitud), 0) / camposFinales.length).toFixed(1) + '%'\n};\n\n// Generar reporte en texto para el LLM\nconst reporteTexto = `\nAN√ÅLISIS DE ESTRUCTURA CSV\n==========================\n\nResumen General:\n- Total de registros: ${totalRows}\n- Total de campos: ${camposFinales.length}\n- Completitud promedio: ${resumenEjecutivo.completitudPromedio}\n\nCampos Detectados por Tipo:\n${Object.entries(resumenEjecutivo.camposIdentificados)\n  .filter(([tipo, campos]) => campos.length > 0)\n  .map(([tipo, campos]) => `- ${tipo}: ${campos.join(', ')}`)\n  .join('\\n')}\n\nCampos Categ√≥ricos (ideales para agrupaci√≥n):\n${resumenEjecutivo.camposCategoricos.join(', ') || 'Ninguno detectado'}\n\nCampos Num√©ricos (con rangos):\n${camposFinales\n  .filter(c => c.rangoNumerico)\n  .map(c => `- ${c.campo}: ${c.rangoNumerico.minimo} a ${c.rangoNumerico.maximo}`)\n  .join('\\n') || 'Ninguno detectado'}\n\nCampos de Texto Largo (>100 caracteres):\n${resumenEjecutivo.camposTextoLargo.join(', ') || 'Ninguno detectado'}\n\nDetalles por Campo:\n${camposFinales\n  .map(c => `\n${c.campo}:\n  - Tipo detectado: ${c.tipoContenido}\n  - Completitud: ${c.completitud}\n  - Valores √∫nicos: ${c.valoresUnicos}\n  - Ejemplos: ${c.ejemplos.map(e => typeof e === 'string' ? `\"${e}\"` : e).join(', ')}`)\n  .join('\\n')}\n`;\n\n// Retornar toda la informaci√≥n\nreturn [{\n  json: {\n    // Lista simple de campos (para compatibilidad con el prompt original)\n    campos: camposFinales.map(c => c.campo),\n    \n    // An√°lisis completo\n    analisisCompleto: {\n      resumen: resumenEjecutivo,\n      camposDetallados: camposFinales,\n      reporteTexto: reporteTexto\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1344,
        2928
      ],
      "id": "75103915-96db-4fd7-8e73-156416a48ce6",
      "name": "Transformador de CSV"
    },
    {
      "parameters": {
        "fieldsToAggregate": {
          "fieldToAggregate": [
            {
              "fieldToAggregate": "product_id"
            },
            {
              "fieldToAggregate": "product_name"
            },
            {
              "fieldToAggregate": "category"
            },
            {
              "fieldToAggregate": "brand"
            },
            {
              "fieldToAggregate": "price"
            },
            {
              "fieldToAggregate": "stock_quantity"
            },
            {
              "fieldToAggregate": "description"
            },
            {
              "fieldToAggregate": "rating"
            },
            {
              "fieldToAggregate": "num_reviews"
            },
            {
              "fieldToAggregate": "is_available"
            },
            {
              "fieldToAggregate": "created_at"
            },
            {
              "fieldToAggregate": "last_restock_date"
            },
            {
              "fieldToAggregate": "serving_size"
            },
            {
              "fieldToAggregate": "flavor"
            },
            {
              "fieldToAggregate": "goals"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        2016,
        2608
      ],
      "id": "3f1b0c3e-71b5-40a8-87e2-22155ce7d436",
      "name": "Aggregate"
    },
    {
      "parameters": {
        "fieldsToSummarize": {
          "values": [
            {
              "aggregation": "concatenate",
              "field": "product_name"
            },
            {
              "aggregation": "concatenate",
              "field": "category"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.summarize",
      "typeVersion": 1.1,
      "position": [
        2256,
        2608
      ],
      "id": "fd6d116f-e623-4488-8135-ee376b79f32c",
      "name": "Summarize2"
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "1n7K2YyE2Kb2kmcLtfGzi_U-tbDactc0e",
          "mode": "list",
          "cachedResultName": "ordenanzas_municipales.md",
          "cachedResultUrl": "https://drive.google.com/file/d/1n7K2YyE2Kb2kmcLtfGzi_U-tbDactc0e/view?usp=drivesdk"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        1248,
        2416
      ],
      "id": "a1f7c725-7a01-4e51-aeb8-667f63635913",
      "name": "Google Drive2",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "RLnwwTctbVu2NRix",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "mode": "insert",
        "memoryKey": {
          "__rl": true,
          "value": "ordenanzas2",
          "mode": "list"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStoreInMemory",
      "typeVersion": 1.3,
      "position": [
        3456,
        2384
      ],
      "id": "a555a7c1-2efe-49d3-a4c3-3a48449425fa",
      "name": "Simple Vector Store"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.body.query }}",
        "options": {
          "systemMessage": "Eres un asistente virtual de la Municipalidad de San Miguel. Usa la base documental para responder.\nPara responder, ten en cuenta los siguientes requisitos:\n1. Debes manejar correctamente las ambiguedades, no des informacion sin estar totalmente seguro de lo que desea el usuario, corrobora lo que desea haciendole las preguntas necesarias.\n2. No des informacion demasiado extensa, solo responde especificamente lo que te preguntan. No des informacion extra a la que se te solicita.\n3. Si no encuentras informaci√≥n exacta, responde: \"Por favor contacte a un funcionario en l√≠nea al n√∫mero 0800-123-456\"."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        2880,
        1152
      ],
      "id": "070abc6c-e76f-42e9-b7a6-541643db9c46",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5-mini",
          "mode": "list",
          "cachedResultName": "gpt-5-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        2464,
        1344
      ],
      "id": "41f8b5e4-1157-4e5a-89d5-9910e6c8c355",
      "name": "OpenAI Chat Model3",
      "credentials": {
        "openAiApi": {
          "id": "FnGS5Jhx56bncQXg",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.body.session_id }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        2752,
        1488
      ],
      "id": "5a253f81-fbf1-4aa2-92f7-815fe0f94cbc",
      "name": "Simple Memory"
    },
    {
      "parameters": {
        "mode": "retrieve-as-tool",
        "toolDescription": "Usa esta herramienta para acceder a \"GU√çA DE TR√ÅMITES Y SERVICIOS MUNICIPALES\"",
        "memoryKey": {
          "__rl": true,
          "value": "tramites2",
          "mode": "list",
          "cachedResultName": "tramites2"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStoreInMemory",
      "typeVersion": 1.3,
      "position": [
        3120,
        1456
      ],
      "id": "21d1249c-1247-43cc-ae37-350927d21bbc",
      "name": "Simple Vector Store2"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1.2,
      "position": [
        3072,
        1648
      ],
      "id": "04ff9e48-b79d-4b5b-b929-99c2665a1f65",
      "name": "Embeddings OpenAI2",
      "credentials": {
        "openAiApi": {
          "id": "FnGS5Jhx56bncQXg",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "municipalidad",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        2576,
        1104
      ],
      "id": "bad4e97b-4f1e-4785-9e1c-fa47bfbe2e48",
      "name": "Webhook",
      "webhookId": "2c624762-b982-4c94-a792-ee33f5e09b4a"
    },
    {
      "parameters": {
        "options": {
          "responseCode": 200,
          "responseKey": ""
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        3280,
        1216
      ],
      "id": "6e4cc50f-a3e7-4a31-a182-4599b2d8edf1",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "mode": "retrieve-as-tool",
        "toolDescription": "Usa esta herramienta para acceder a \"REGISTRO DE ORDENANZAS MUNICIPALES\"",
        "memoryKey": {
          "__rl": true,
          "value": "ordenanzas2",
          "mode": "list",
          "cachedResultName": "ordenanzas2"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStoreInMemory",
      "typeVersion": 1.3,
      "position": [
        3440,
        1456
      ],
      "id": "ccbfd51f-2fb3-4406-8fa3-438b7eb8e053",
      "name": "Simple Vector Store3"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1.2,
      "position": [
        3536,
        1648
      ],
      "id": "fecb46e5-77da-4c20-aada-3f390342d0e7",
      "name": "Embeddings OpenAI3",
      "credentials": {
        "openAiApi": {
          "id": "FnGS5Jhx56bncQXg",
          "name": "OpenAi account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Embeddings OpenAI": {
      "ai_embedding": [
        [
          {
            "node": "Supabase Vector Store",
            "type": "ai_embedding",
            "index": 0
          },
          {
            "node": "Simple Vector Store",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader": {
      "ai_document": [
        [
          {
            "node": "Supabase Vector Store",
            "type": "ai_document",
            "index": 0
          },
          {
            "node": "Simple Vector Store",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Summarize": {
      "main": [
        [
          {
            "node": "Simple Vector Store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Context": {
      "main": [
        [
          {
            "node": "Summarize",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Character Text Splitter": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "Extract from PDF": {
      "main": [
        [
          {
            "node": "PDF TO DATA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PDF TO DATA": {
      "main": [
        [
          {
            "node": "Document Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CR SWITCH": {
      "main": [
        [
          {
            "node": "Extract from PDF",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract from TXT",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract from TXT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Document Data": {
      "main": [
        [
          {
            "node": "Recursive Splitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Recursive Splitter": {
      "main": [
        [
          {
            "node": "Split Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Chunks": {
      "main": [
        [
          {
            "node": "Add Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Add Context",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‚ÄòTest workflow‚Äô": {
      "main": [
        [
          {
            "node": "Google Drive2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from TXT": {
      "main": [
        [
          {
            "node": "PDF TO DATA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields2": {
      "main": [
        [
          {
            "node": "Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "LLM ANALISTA",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields4": {
      "main": [
        [
          {
            "node": "LLM CODIGO",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "LLM CODIGO",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Split Out": {
      "main": [
        [
          {
            "node": "Summarize1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarize1": {
      "main": [
        [
          {
            "node": "Supabase Vector Store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM ANALISTA": {
      "main": [
        [
          {
            "node": "Edit Fields4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM CODIGO": {
      "main": [
        [
          {
            "node": "Edit Fields2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunks": {
      "main": [
        [
          {
            "node": "Agrupar Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agrupar Items": {
      "main": [
        [
          {
            "node": "Split Out",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transformador de CSV": {
      "main": [
        [
          {
            "node": "LLM ANALISTA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate": {
      "main": [
        [
          {
            "node": "Summarize2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Drive2": {
      "main": [
        [
          {
            "node": "CR SWITCH",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Simple Vector Store2": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings OpenAI2": {
      "ai_embedding": [
        [
          {
            "node": "Simple Vector Store2",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Simple Vector Store3": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings OpenAI3": {
      "ai_embedding": [
        [
          {
            "node": "Simple Vector Store3",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "64e67f46-be21-4661-890b-7a553e822708",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "22c07b1f210778c35286fa3bb5e03cbbfa8bada783456421edc4182c21f0c0ce"
  },
  "id": "wn30BkV5hrKy9iXo",
  "tags": []
}